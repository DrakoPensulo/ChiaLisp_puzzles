Chia singleton note. 

Goal: To learn about chia singletos, how to mint, transfer and melt. 

Challenge: Get the free 0.3 XCH at the "singleton_launcher.clvm" address.  

[The form of this note will not be improved (by me)] 

(if you want to follow/mimic steps on this note, you can send some txch on testnet to the address corresponding to this puzzle_hash,
this correspondig address you get by executing 
cdv encode --prefix txch eff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9
txch1alc82gjf2psvqehkdue2es480caruum6e296afx35e82fnwp8k5shty4cp
and then use 'chia wallet send'  command)


(I did not use Python or rust at all in this note to focus solely on the way singletons work on the blockchain) 



(As you can see, I did not spend time on making this note to look pretty, it is just a text file basically. If you would like to improve the way this note looks, contact me)


Required: 
1) Python enviroment with chia-blockchain and chia-dev-tools installed. 
2) Puzzles singleton_top_layer_v1_1.clvm, singleton_launcher.clvm from the chia github repository https://github.com/Chia-Network/chia-blockchain/tree/8b70466a70388d0fff437d138192ba38faf92be8/chia/wallet/puzzles.  
to the \include directory download condition_codes.clvm, sha256tree_module.clvm, singleton_truths.clib and utility_macros.clib
You can also find all these files in your Python Enviroment in venv\lib\site-packages\chia\wallet\puzzles
3) Full node (testnet or mainnet)

Recommended reading: https://chialisp.com/singletons/



To simplify the presentation and focus solely on singletons, we avoid using singnatures (that approach should never be used as it is insecure, in the sense that the spend bundles can be modified by any one who observes the mempool). 


Execution of the following command returns an unspent coin which we can "intercept".

cdv rpc coinrecords --by puzzlehash eff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9 -ou -nd
{
    "4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412": {
        "coin": {
            "amount": 300000000000,
            "parent_coin_info": "0x5ff6e8f3c1541fdb3b5476e9ea2c95f5ee97b8c8a3a30967c3f9e663b7f648b6",
            "puzzle_hash": "0xeff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9"
        },
        "coinbase": false,
        "confirmed_block_index": 6105259,
        "spent_block_index": 0,
        "timestamp": 1729645480
    }
}

The puzzle_hash 0xeff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9 is LAUNCHER_PUZZLE_HASH (we will verify that below).
The coinid 0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412 is LAUNCHER_ID 


In order to create a singleton using this launcher coin we need to prepare a correct spend bundle. The template is

{
  "coin_spends": [
    {
      "coin": {
        "amount": 0,
        "parent_coin_info": "",
        "puzzle_hash": ""
      },
      "puzzle_reveal": "",
      "solution": ""
    },
	{
      "coin": {
        "amount": 0,
        "parent_coin_info": "",
        "puzzle_hash": ""
      },
      "puzzle_reveal": "",
      "solution": ""
    }
 ],
  "aggregated_signature": "c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
}


At this point we can copy-paste 3 fields of the first coin. 


{
  "coin_spends": [
    {
      "coin": {
        "amount": 300000000000,
        "parent_coin_info": "0x5ff6e8f3c1541fdb3b5476e9ea2c95f5ee97b8c8a3a30967c3f9e663b7f648b6",
        "puzzle_hash": "0xeff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9"
      },
      "puzzle_reveal": "",
      "solution": ""
    },
	{
      "coin": {
        "amount": 0,
        "parent_coin_info": "",
        "puzzle_hash": ""
      },
      "puzzle_reveal": "",
      "solution": ""
    }
 ],
  "aggregated_signature": "c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
}


Now we verify that this coin is protected by the singleton_launcher puzzle. 


First, we compile the puzzle

cdv clsp build singleton_launcher.clvm

Next, we disassemble it


cdv clsp disassemble singleton_launcher.clvm.hex
(a (q 4 (c 4 (c 5 (c 11 ()))) (c (c 10 (c (a 14 (c 2 (c (c 5 (c 11 (c 23 ()))) ()))) ())) ())) (c (q 51 60 2 (i (l 5) (q 11 (q . 2) (a 14 (c 2 (c 9 ()))) (a 14 (c 2 (c 13 ())))) (q 11 (q . 1) 5)) 1) 1))


We calculate the puzzle_hash

opc -H "(a (q 4 (c 4 (c 5 (c 11 ()))) (c (c 10 (c (a 14 (c 2 (c (c 5 (c 11 (c 23 ()))) ()))) ())) ())) (c (q 51 60 2 (
i (l 5) (q 11 (q . 2) (a 14 (c 2 (c 9 ()))) (a 14 (c 2 (c 13 ())))) (q 11 (q . 1) 5)) 1) 1))"
eff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9


We see that the above coin is protected by the singleton_launcher puzzle. Spending this coin creates a singleton. 
We want to create a singleton which we can later melt and send (about) 0.3 xch of that coin to our address. 


Compile the above clvm script


opc "(a (q 4 (c 4 (c 5 (c 11 ()))) (c (c 10 (c (a 14 (c 2 (c (c 5 (c 11 (c 23 ()))) ()))) ())) ())) (c (q 51 60 2 (i (
l 5) (q 11 (q . 2) (a 14 (c 2 (c 9 ()))) (a 14 (c 2 (c 13 ())))) (q 11 (q . 1) 5)) 1) 1))"
ff02ffff01ff04ffff04ff04ffff04ff05ffff04ff0bff80808080ffff04ffff04ff0affff04ffff02ff0effff04ff02ffff04ffff04ff05ffff04ff0bffff04ff17ff80808080ff80808080ff808080ff808080ffff04ffff01ff33ff3cff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff0effff04ff02ffff04ff09ff80808080ffff02ff0effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ff018080

The compiled code we paste to our spend bundle, adding 0x at the beginning.



{
  "coin_spends": [
    {
      "coin": {
        "amount": 300000000000,
        "parent_coin_info": "0x5ff6e8f3c1541fdb3b5476e9ea2c95f5ee97b8c8a3a30967c3f9e663b7f648b6",
        "puzzle_hash": "0xeff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9"
      },
      "puzzle_reveal": "0xff02ffff01ff04ffff04ff04ffff04ff05ffff04ff0bff80808080ffff04ffff04ff0affff04ffff02ff0effff04ff02ffff04ffff04ff05ffff04ff0bffff04ff17ff80808080ff80808080ff808080ff808080ffff04ffff01ff33ff3cff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff0effff04ff02ffff04ff09ff80808080ffff02ff0effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ff018080",
      "solution": ""
    },
	{
      "coin": {
        "amount": 0,
        "parent_coin_info": "",
        "puzzle_hash": ""
      },
      "puzzle_reveal": "",
      "solution": ""
    }
 ],
  "aggregated_signature": "c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
}


Next, we need to prepare the solution to this puzzle.



The puzzle singleton_launcher.clvm takes 3 parameters

(singleton_full_puzzle_hash amount key_value_list)

The 2nd parameter is the amount for our to-be-created singleton. It has to be odd. We will make it 0.3 xch - 1 mojo  = 299999999999 mojos = 0x45D964B7FF. In this case 1 mojo will be the blockchian fee. 
Note: If you follow the steps on testnet or on mainnet there are already higher fees to push a transaction, you should subract (much?) more than 1 mojo. 
 
The 3rd parameters we do not worry about, we just make it '()'. 

We need to work harder on the first parameter. 

We will use the following inner_puzzle for the singleton (paste the below code to the file singleton_inner_puzzle.clsp). 

(mod (sendto_puzhash amount)

     (include condition_codes.clib)

	(list 
		(list CREATE_COIN sendto_puzhash amount)
	)
)


Note: The above puzzle is not safe in the sense that a singleton with this inner puzzle can be spent by everybody. 

cdv clsp build singleton_inner_puzzle.clsp
cdv clsp disassemble singleton_inner_puzzle.clsp.hex

(a (q 4 (c 2 (c 5 (c 11 ()))) ()) (c (q . 51) 1))

(myvenv) c:\MySrc\ChiaLisp\Singletons>cdv clsp disassemble singleton_inner_puzzle.clsp.hex
(a (q 4 (c 2 (c 5 (c 11 ()))) ()) (c (q . 51) 1))

(myvenv) c:\MySrc\ChiaLisp\Singletons>opc "(a (q 4 (c 2 (c 5 (c 11 ()))) ()) (c (q . 51) 1))"
ff02ffff01ff04ffff04ff02ffff04ff05ffff04ff0bff80808080ff8080ffff04ffff0133ff018080

(myvenv) c:\MySrc\ChiaLisp\Singletons>opc -H "(a (q 4 (c 2 (c 5 (c 11 ()))) ()) (c (q . 51) 1))"
e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79

(myvenv) c:\MySrc\ChiaLisp\Singletons>cdv encode --prefix xch e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79
xch1uqtwrr4lyad9ur0m5za86akxj6d8ylheq0090gmns6h7l9z0heusdtw52s


We use singleton_top_layer_v1_1.clvm. It needs 2 parameters to be curried. 
The second parameter is the INNER_PUZZLE we obtained above. That inner puzzle 'protects' the singleton. It enforces rules which have to be followed in order for the singleton to be spent. Our INNER_PUZZLE is '(a (q 4 (c 2 (c 5 (c 11 ()))) ()) (c (q . 51) 1))'

cdv clsp build singleton_top_layer_v1_1.clvm

cdv clsp disassemble singleton_top_layer_v1_1.clvm.hex
opc -H "(a (q 2 (i (logand 47 52) (q 4 (c 32 (c 47 ())) (c (a 62 (c 2 (c 5 (c (a 42 (c 2 (c 39 (c (a (i 119 (q 2 54 (c 2 (c 9 (c 87 (c (a 46 (c 2 (c 5 ()))) ()))))) (q . 29)) 1) (c (a (i 119 (q . -73) (q . 87)) 1) ()))))) (c 119 ()))))) (a 58 (c 2 (c 5 (c (a 11 95) (q ()))))))) (q 8)) 1) (c (q (((73 . 71) 2 . 51) (c . 1) 1 . 2) ((not 2 (i 5 (q 2 50 (c 2 (c 13 (c (sha256 60 (sha256 52 36) (sha256 60 (sha256 60 (sha256 52 44) 9) (sha256 60 11 (sha256 52 ())))) ())))) (q . 11)) 1) (a (i (all (= (strlen 5) 34) (= (strlen 11) 34) (> 23 (q . -1))) (q 11 5 11 23) (q 8)) 1) 2 (i 11 (q 2 (i (a 38 (c 2 (c 19 ()))) (q 2 (i (not 23) (q 2 (i (= -77 (q . -113)) (q 2 58 (c 2 (c 5 (c 27 (c 52 ()))))) (q 4 (c 35 (c (a 54 (c 2 (c 9 (c 83 (c (a 46 (c 2 (c 5 ()))) ()))))) 115)) (a 58 (c 2 (c 5 (c 27 (c 52 ()))))))) 1) (q 8)) 1) (q 4 19 (a 58 (c 2 (c 5 (c 27 (c 23 ()))))))) 1) (q 2 (i 23 () (q 8)) 1)) 1) ((a (i (= 9 56) (q 2 (i (logand 45 (q . 1)) (q 1 . 1) ()) 1) ()) 1) 11 60 (sha256 52 40) (sha256 60 (sha256 60 (sha256 52 44) 5) (sha256 60 (a 50 (c 2 (c 7 (c (sha256 52 52) ())))) (sha256 52 ())))) (a (i (l 5) (q 11 (q . 2) (a 46 (c 2 (c 9 ()))) (a 46 (c 2 (c 13 ())))) (q 11 (q . 1) 5)) 1) 2 (i (any 23 (= 11 21)) (q 4 48 (c 11 ())) (q 8)) 1) 1))"
7faa3253bfddd1e0decb0906b2dc6247bbc4cf608f58345d173adb63e8b47c9f

The hash 7faa3253bfddd1e0decb0906b2dc6247bbc4cf608f58345d173adb63e8b47c9f is MOD_HASH which we use below. 


the first curried in argument to the singleton_top_layer is 

SINGLETON_STRUCT = (MOD_HASH . (LAUNCHER_ID . LAUNCHER_PUZZLE_HASH))

MOD_HASH is the puzzle_hash of singleton_top_layer_v1_1, that is 7faa3253bfddd1e0decb0906b2dc6247bbc4cf608f58345d173adb63e8b47c9f
The following two parameters were obtained at the beginning.
LAUNCHER_ID is the coinid of the coin which 'creates' the singleton, in our case of this 0.3 xch coin, that is 0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412
LAUNCHER_PUZZLE_HASH is the puzzle_hash of the singleton_launcher puzzle 0xeff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9

Execute the following command (DO NOT forget about '0x' before the hashes) to curry in both arguments
 
cdv clsp curry singleton_top_layer_v1_1.clvm -a "(0x7faa3253bfddd1e0decb0906b2dc6247bbc4cf608f58345d173adb63e8b47c9f 0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412 . 0xeff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9)" -a "(a (q 4 (c 2 (c 5 (c 11 ()))) ()) (c (q . 51) 1))"

(a (q 2 (q 2 (i (logand 47 52) (q 4 (c 32 (c 47 ())) (c (a 62 (c 2 (c 5 (c (a 42 (c 2 (c 39 (c (a (i 119 (q 2 54 (c 2 (c 9 (c 87 (c (a 46 (c 2 (c 5 ()))) ()))))) (q . 29)) 1) (c (a (i 119 (q . -73) (q . 87)) 1) ()))))) (c 119 ()))))) (a 58 (c 2 (c 5 (c (a 11 95) (q ()))))))) (q 8)) 1) (c (q (((73 . 71) 2 . 51) (c . 1) 1 . 2) ((not 2 (i 5 (q 2 50 (c 2 (c 13 (c (sha256 60 (sha256 52 36) (sha256 60 (sha256 60 (sha256 52 44) 9) (sha256 60 11 (sha256 52 ())))) ())))) (q . 11)) 1) (a (i (all (= (strlen 5) 34) (= (strlen 11) 34) (> 23 (q . -1))) (q 11 5 11 23) (q 8)) 1) 2 (i 11 (q 2 (i (a 38 (c 2 (c 19 ()))) (q 2 (i (not 23) (q 2 (i (= -77 (q . -113)) (q 2 58 (c 2 (c 5 (c 27 (c 52 ()))))) (q 4 (c 35 (c (a 54 (c 2 (c 9 (c 83 (c (a 46 (c 2 (c 5 ()))) ()))))) 115)) (a 58 (c 2 (c 5 (c 27 (c 52 ()))))))) 1) (q 8)) 1) (q 4 19 (a 58 (c 2 (c 5 (c 27 (c 23 ()))))))) 1) (q 2 (i 23 () (q 8)) 1)) 1) ((a (i (= 9 56) (q 2 (i (logand 45 (q . 1)) (q 1 . 1) ()) 1) ()) 1) 11 60 (sha256 52 40) (sha256 60 (sha256 60 (sha256 52 44) 5) (sha256 60 (a 50 (c 2 (c 7 (c (sha256 52 52) ())))) (sha256 52 ())))) (a (i (l 5) (q 11 (q . 2) (a 46 (c 2 (c 9 ()))) (a 46 (c 2 (c 13 ())))) (q 11 (q . 1) 5)) 1) 2 (i (any 23 (= 11 21)) (q 4 48 (c 11 ())) (q 8)) 1) 1)) (c (q 0x7faa3253bfddd1e0decb0906b2dc6247bbc4cf608f58345d173adb63e8b47c9f 0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412 . 0xeff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9) (c (q 2 (q 4 (c 2 (c 5 (c 11 ()))) ()) (c (q . 51) 1)) 1)))


Calculate the hash of the above puzzle:


opc -H "(a (q 2 (q 2 (i (logand 47 52) (q 4 (c 32 (c 47 ())) (c (a 62 (c 2 (c 5 (c (a 42 (c 2 (c 39 (c (a (i 119 (q 2 54 (c 2 (c 9 (c 87 (c (a 46 (c 2 (c 5 ()))) ()))))) (q . 29)) 1) (c (a (i 119 (q . -73) (q . 87)) 1) ()))))) (c 119 ()))))) (a 58 (c 2 (c 5 (c (a 11 95) (q ()))))))) (q 8)) 1) (c (q (((73 . 71) 2 . 51) (c . 1) 1 . 2) ((not 2 (i 5 (q 2 50 (c 2 (c 13 (c (sha256 60 (sha256 52 36) (sha256 60 (sha256 60 (sha256 52 44) 9) (sha256 60 11 (sha256 52 ())))) ())))) (q . 11)) 1) (a (i (all (= (strlen 5) 34) (= (strlen 11) 34) (> 23 (q . -1))) (q 11 5 11 23) (q 8)) 1) 2 (i 11 (q 2 (i (a 38 (c 2 (c 19 ()))) (q 2 (i (not 23) (q 2 (i (= -77 (q . -113)) (q 2 58 (c 2 (c 5 (c 27 (c 52 ()))))) (q 4 (c 35 (c (a 54 (c 2 (c 9 (c 83 (c (a 46 (c 2 (c 5 ()))) ()))))) 115)) (a 58 (c 2 (c 5 (c 27 (c 52 ()))))))) 1) (q 8)) 1) (q 4 19 (a 58 (c 2 (c 5 (c 27 (c 23 ()))))))) 1) (q 2 (i 23 () (q 8)) 1)) 1) ((a (i (= 9 56) (q 2 (i (logand 45 (q . 1)) (q 1 . 1) ()) 1) ()) 1) 11 60 (sha256 52 40) (sha256 60 (sha256 60 (sha256 52 44) 5) (sha256 60 (a 50 (c 2 (c 7 (c (sha256 52 52) ())))) (sha256 52 ())))) (a (i (l 5) (q 11 (q . 2) (a 46 (c 2 (c 9 ()))) (a 46 (c 2 (c 13 ())))) (q 11 (q . 1) 5)) 1) 2 (i (any 23 (= 11 21)) (q 4 48 (c 11 ())) (q 8)) 1) 1)) (c (q 0x7faa3253bfddd1e0decb0906b2dc6247bbc4cf608f58345d173adb63e8b47c9f 0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412 . 0xeff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9) (c (q 2 (q 4 (c 2 (c 5 (c 11 ()))) ()) (c (q . 51) 1)) 1)))"
1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1


Execute the above command without -H parameter to get compiled code of this puzzle. That is the puzzle_reveal for the second coin.


The hash 1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 is the singleton_full_puzzle_hash, the first parameter to the singleton_launcher puzzle. 


Now, we build the solution for that puzzle


opc "(0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 299999999999 ())"
ffa01bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1ff8545d964b7ffff8080

We paste the solution to our spend_bundle (do not forget about "0x")

{
  "coin_spends": [
    {
      "coin": {
        "amount": 300000000000,
        "parent_coin_info": "0x5ff6e8f3c1541fdb3b5476e9ea2c95f5ee97b8c8a3a30967c3f9e663b7f648b6",
        "puzzle_hash": "0xeff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9"
      },
      "puzzle_reveal": "0xff02ffff01ff04ffff04ff04ffff04ff05ffff04ff0bff80808080ffff04ffff04ff0affff04ffff02ff0effff04ff02ffff04ffff04ff05ffff04ff0bffff04ff17ff80808080ff80808080ff808080ff808080ffff04ffff01ff33ff3cff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff0effff04ff02ffff04ff09ff80808080ffff02ff0effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ff018080",
      "solution": "0xffa01bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1ff8545d964b7ffff8080"
    },
	{
      "coin": {
        "amount": 0,
        "parent_coin_info": "",
        "puzzle_hash": ""
      },
      "puzzle_reveal": "",
      "solution": ""
    }
 ],
  "aggregated_signature": "c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
}




We can test the puzzle with our solution

brun "(a (q 4 (c 4 (c 5 (c 11 ()))) (c (c 10 (c (a 14 (c 2 (c (c 5 (c 11 (c 23 ()))) ()))) ())) ())) (c (q 51 60 2 (i (l 5) (q 11 (q . 2) (a 14 (c 2 (c 9 ()))) (a 14 (c 2 (c 13 ())))) (q 11 (q . 1) 5)) 1) 1))" "(0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 299999999999 ())"

((51 0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 0x45d964b7ff) (60 0x9b96f6a3188f98726554142f16ae22206fef1e899ddd09b118d073c670571df0))


If everything goes well, when we spend the above launcher coin with the solution there will be a singleton coin created (51) which we need to spent in the same block. 


Now, we need to take care about the second coin in the spend bundle. We need to spend the coin which is created by the launcher_coin. We know its amount 299999999999, puzzle_hash 0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 and its parent which is the launcher_coin_id 4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412

The puzzle_reveal was obtained above. 


The solution we obtain in the following way. 

The singleton spend requires three parameters:
(lineage_proof my_amount inner_solution)
for the first singleton spend the lineage_proof has the format:
(parent_parent_coin_info parent_amount)

( (0x5ff6e8f3c1541fdb3b5476e9ea2c95f5ee97b8c8a3a30967c3f9e663b7f648b6 300000000000) 299999999999  (0xe016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79 299999999999) )


opc "( (0x5ff6e8f3c1541fdb3b5476e9ea2c95f5ee97b8c8a3a30967c3f9e663b7f648b6 300000000000) 299999999999  (0xe016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79 299999999999) )"
ffffa05ff6e8f3c1541fdb3b5476e9ea2c95f5ee97b8c8a3a30967c3f9e663b7f648b6ff8545d964b80080ff8545d964b7ffffffa0e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79ff8545d964b7ff8080


{
  "coin_spends": [
    {
      "coin": {
        "amount": 300000000000,
        "parent_coin_info": "0x5ff6e8f3c1541fdb3b5476e9ea2c95f5ee97b8c8a3a30967c3f9e663b7f648b6",
        "puzzle_hash": "0xeff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9"
      },
      "puzzle_reveal": "0xff02ffff01ff04ffff04ff04ffff04ff05ffff04ff0bff80808080ffff04ffff04ff0affff04ffff02ff0effff04ff02ffff04ffff04ff05ffff04ff0bffff04ff17ff80808080ff80808080ff808080ff808080ffff04ffff01ff33ff3cff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff0effff04ff02ffff04ff09ff80808080ffff02ff0effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ff018080",
      "solution": "0xffa01bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1ff8545d964b7ffff8080"
    },
	{
      "coin": {
        "amount": 299999999999,
        "parent_coin_info": "0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412",
        "puzzle_hash": "0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1"
      },
      "puzzle_reveal": "0xff02ffff01ff02ffff01ff02ffff03ffff18ff2fff3480ffff01ff04ffff04ff20ffff04ff2fff808080ffff04ffff02ff3effff04ff02ffff04ff05ffff04ffff02ff2affff04ff02ffff04ff27ffff04ffff02ffff03ff77ffff01ff02ff36ffff04ff02ffff04ff09ffff04ff57ffff04ffff02ff2effff04ff02ffff04ff05ff80808080ff808080808080ffff011d80ff0180ffff04ffff02ffff03ff77ffff0181b7ffff015780ff0180ff808080808080ffff04ff77ff808080808080ffff02ff3affff04ff02ffff04ff05ffff04ffff02ff0bff5f80ffff01ff8080808080808080ffff01ff088080ff0180ffff04ffff01ffffffff4947ff0233ffff0401ff0102ffffff20ff02ffff03ff05ffff01ff02ff32ffff04ff02ffff04ff0dffff04ffff0bff3cffff0bff34ff2480ffff0bff3cffff0bff3cffff0bff34ff2c80ff0980ffff0bff3cff0bffff0bff34ff8080808080ff8080808080ffff010b80ff0180ffff02ffff03ffff22ffff09ffff0dff0580ff2280ffff09ffff0dff0b80ff2280ffff15ff17ffff0181ff8080ffff01ff0bff05ff0bff1780ffff01ff088080ff0180ff02ffff03ff0bffff01ff02ffff03ffff02ff26ffff04ff02ffff04ff13ff80808080ffff01ff02ffff03ffff20ff1780ffff01ff02ffff03ffff09ff81b3ffff01818f80ffff01ff02ff3affff04ff02ffff04ff05ffff04ff1bffff04ff34ff808080808080ffff01ff04ffff04ff23ffff04ffff02ff36ffff04ff02ffff04ff09ffff04ff53ffff04ffff02ff2effff04ff02ffff04ff05ff80808080ff808080808080ff738080ffff02ff3affff04ff02ffff04ff05ffff04ff1bffff04ff34ff8080808080808080ff0180ffff01ff088080ff0180ffff01ff04ff13ffff02ff3affff04ff02ffff04ff05ffff04ff1bffff04ff17ff8080808080808080ff0180ffff01ff02ffff03ff17ff80ffff01ff088080ff018080ff0180ffffff02ffff03ffff09ff09ff3880ffff01ff02ffff03ffff18ff2dffff010180ffff01ff0101ff8080ff0180ff8080ff0180ff0bff3cffff0bff34ff2880ffff0bff3cffff0bff3cffff0bff34ff2c80ff0580ffff0bff3cffff02ff32ffff04ff02ffff04ff07ffff04ffff0bff34ff3480ff8080808080ffff0bff34ff8080808080ffff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff2effff04ff02ffff04ff09ff80808080ffff02ff2effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ff02ffff03ffff21ff17ffff09ff0bff158080ffff01ff04ff30ffff04ff0bff808080ffff01ff088080ff0180ff018080ffff04ffff01ffa07faa3253bfddd1e0decb0906b2dc6247bbc4cf608f58345d173adb63e8b47c9fffa04255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412a0eff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9ffff04ffff01ff02ffff01ff04ffff04ff02ffff04ff05ffff04ff0bff80808080ff8080ffff04ffff0133ff018080ff01808080",
      "solution": "0xffffa05ff6e8f3c1541fdb3b5476e9ea2c95f5ee97b8c8a3a30967c3f9e663b7f648b6ff8545d964b80080ff8545d964b7ffffffa0e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79ff8545d964b7ff8080"
    }
 ],
  "aggregated_signature": "c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
}


We test our second coin spend. 

Decode the solution.
opd "ffffa05ff6e8f3c1541fdb3b5476e9ea2c95f5ee97b8c8a3a30967c3f9e663b7f648b6ff8545d964b80080ff8545d964b7ffffffa0e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79ff8545d964b7ff8080"
((0x5ff6e8f3c1541fdb3b5476e9ea2c95f5ee97b8c8a3a30967c3f9e663b7f648b6 0x45d964b800) 0x45d964b7ff (0xe016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79 0x45d964b7ff))
Decode the puzzle_reveal using opd or copy from above.

Execute:

brun "(a (q 2 (q 2 (i (logand 47 52) (q 4 (c 32 (c 47 ())) (c (a 62 (c 2 (c 5 (c (a 42 (c 2 (c 39 (c (a (i 119 (q 2 54 (c 2 (c 9 (c 87 (c (a 46 (c 2 (c 5 ()))) ()))))) (q . 29)) 1) (c (a (i 119 (q . -73) (q . 87)) 1) ()))))) (c 119 ()))))) (a 58 (c 2 (c 5 (c (a 11 95) (q ()))))))) (q 8)) 1) (c (q (((73 . 71) 2 . 51) (c . 1) 1 . 2) ((not 2 (i 5 (q 2 50 (c 2 (c 13 (c (sha256 60 (sha256 52 36) (sha256 60 (sha256 60 (sha256 52 44) 9) (sha256 60 11 (sha256 52 ())))) ())))) (q . 11)) 1) (a (i (all (= (strlen 5) 34) (= (strlen 11) 34) (> 23 (q . -1))) (q 11 5 11 23) (q 8)) 1) 2 (i 11 (q 2 (i (a 38 (c 2 (c 19 ()))) (q 2 (i (not 23) (q 2 (i (= -77 (q . -113)) (q 2 58 (c 2 (c 5 (c 27 (c 52 ()))))) (q 4 (c 35 (c (a 54 (c 2 (c 9 (c 83 (c (a 46 (c 2 (c 5 ()))) ()))))) 115)) (a 58 (c 2 (c 5 (c 27 (c 52 ()))))))) 1) (q 8)) 1) (q 4 19 (a 58 (c 2 (c 5 (c 27 (c 23 ()))))))) 1) (q 2 (i 23 () (q 8)) 1)) 1) ((a (i (= 9 56) (q 2 (i (logand 45 (q . 1)) (q 1 . 1) ()) 1) ()) 1) 11 60 (sha256 52 40) (sha256 60 (sha256 60 (sha256 52 44) 5) (sha256 60 (a 50 (c 2 (c 7 (c (sha256 52 52) ())))) (sha256 52 ())))) (a (i (l 5) (q 11 (q . 2) (a 46 (c 2 (c 9 ()))) (a 46 (c 2 (c 13 ())))) (q 11 (q . 1) 5)) 1) 2 (i (any 23 (= 11 21)) (q 4 48 (c 11 ())) (q 8)) 1) 1)) (c (q 0x7faa3253bfddd1e0decb0906b2dc6247bbc4cf608f58345d173adb63e8b47c9f 0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412 . 0xeff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9) (c (q 2 (q 4 (c 2 (c 5 (c 11 ()))) ()) (c (q . 51) 1)) 1)))" "((0x5ff6e8f3c1541fdb3b5476e9ea2c95f5ee97b8c8a3a30967c3f9e663b7f648b6 0x45d964b800) 0x45d964b7ff (0xe016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79 0x45d964b7ff))"

You should get a list of 3 conditions
((73 0x45d964b7ff) (71 0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412) (51 0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 0x45d964b7ff))

73 is ASSERT_MY_AMOUNT, 71 is ASSERT_MY_PARENT_ID, 51 is CREATE_COIN


Observe that the puzzle_hash of the to-be-created coin is the same as the puzzle_hash of the second coin from our spend bundle. It is justified since both coins are "protected" by the same INNER_PUZZLE (the one from the file singleton_inner_puzzle). 







You can also use mixch.dev to test the whole spend_bundle before pushing to the network. 







====> push to the network  .   cdv rpc pushtx spend_bundle1.json
The expected output:

{
    "status": "SUCCESS",
    "success": true
}

We should be able to find our singleton on chain 


cdv rpc coinrecords --by puzzlehash 1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 -ou -nd

{
    "952599f0d0d7c8d41fbe7e084f2ab2d31f57a541878a82c7124249e501279405": {
        "coin": {
            "amount": 299999999999,
            "parent_coin_info": "0xd2320b2ef89ff3bfa107dfab881c16ef19e4ca3f27197b7d17d685d1064a5aa5",
            "puzzle_hash": "0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1"
        },
        "coinbase": false,
        "confirmed_block_index": 6632156,
        "spent_block_index": 0,
        "timestamp": 1739504741
    }
}

















Next, we learn how transfer the just-created singleton. Again, we need to crate a spend bundle. This time with just one coin. 

Since the puzzle_hash is the same as the second's coin puzzle_hash, the puzzle_reveal is the same. We can copy that.  
  

{
  "coin_spends": [
 	{
      "coin": {
        "amount": 299999999999,
        "parent_coin_info": "0xd2320b2ef89ff3bfa107dfab881c16ef19e4ca3f27197b7d17d685d1064a5aa5",
        "puzzle_hash": "0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1"
      },
      "puzzle_reveal": "0xff02ffff01ff02ffff01ff02ffff03ffff18ff2fff3480ffff01ff04ffff04ff20ffff04ff2fff808080ffff04ffff02ff3effff04ff02ffff04ff05ffff04ffff02ff2affff04ff02ffff04ff27ffff04ffff02ffff03ff77ffff01ff02ff36ffff04ff02ffff04ff09ffff04ff57ffff04ffff02ff2effff04ff02ffff04ff05ff80808080ff808080808080ffff011d80ff0180ffff04ffff02ffff03ff77ffff0181b7ffff015780ff0180ff808080808080ffff04ff77ff808080808080ffff02ff3affff04ff02ffff04ff05ffff04ffff02ff0bff5f80ffff01ff8080808080808080ffff01ff088080ff0180ffff04ffff01ffffffff4947ff0233ffff0401ff0102ffffff20ff02ffff03ff05ffff01ff02ff32ffff04ff02ffff04ff0dffff04ffff0bff3cffff0bff34ff2480ffff0bff3cffff0bff3cffff0bff34ff2c80ff0980ffff0bff3cff0bffff0bff34ff8080808080ff8080808080ffff010b80ff0180ffff02ffff03ffff22ffff09ffff0dff0580ff2280ffff09ffff0dff0b80ff2280ffff15ff17ffff0181ff8080ffff01ff0bff05ff0bff1780ffff01ff088080ff0180ff02ffff03ff0bffff01ff02ffff03ffff02ff26ffff04ff02ffff04ff13ff80808080ffff01ff02ffff03ffff20ff1780ffff01ff02ffff03ffff09ff81b3ffff01818f80ffff01ff02ff3affff04ff02ffff04ff05ffff04ff1bffff04ff34ff808080808080ffff01ff04ffff04ff23ffff04ffff02ff36ffff04ff02ffff04ff09ffff04ff53ffff04ffff02ff2effff04ff02ffff04ff05ff80808080ff808080808080ff738080ffff02ff3affff04ff02ffff04ff05ffff04ff1bffff04ff34ff8080808080808080ff0180ffff01ff088080ff0180ffff01ff04ff13ffff02ff3affff04ff02ffff04ff05ffff04ff1bffff04ff17ff8080808080808080ff0180ffff01ff02ffff03ff17ff80ffff01ff088080ff018080ff0180ffffff02ffff03ffff09ff09ff3880ffff01ff02ffff03ffff18ff2dffff010180ffff01ff0101ff8080ff0180ff8080ff0180ff0bff3cffff0bff34ff2880ffff0bff3cffff0bff3cffff0bff34ff2c80ff0580ffff0bff3cffff02ff32ffff04ff02ffff04ff07ffff04ffff0bff34ff3480ff8080808080ffff0bff34ff8080808080ffff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff2effff04ff02ffff04ff09ff80808080ffff02ff2effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ff02ffff03ffff21ff17ffff09ff0bff158080ffff01ff04ff30ffff04ff0bff808080ffff01ff088080ff0180ff018080ffff04ffff01ffa07faa3253bfddd1e0decb0906b2dc6247bbc4cf608f58345d173adb63e8b47c9fffa04255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412a0eff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9ffff04ffff01ff02ffff01ff04ffff04ff02ffff04ff05ffff04ff0bff80808080ff8080ffff04ffff0133ff018080ff01808080",
      "solution": "0xffffa04255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412ffa0e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79ff8545d964b7ff80ff8545d964b7ffffffa0e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79ff8545d964b7fd8080"
    }
 ],
  "aggregated_signature": "c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
}


The amount is 299999999999, because we created the singleton with that amount (see the CREATE_COIN condition above). The parent_coin_info is the id of the second coin from our previous spend_bundle. We can get it by executing 
cdv rpc coinrecords --by puzzlehash 0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 -ou -nd

or 

cdv inspect -id coins --parent-id 0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412 --puzzle-hash 0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 --amount 299999999999 
['d2320b2ef89ff3bfa107dfab881c16ef19e4ca3f27197b7d17d685d1064a5aa5']

or 

run "(concat 0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412 0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 299999999999)"
0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d4121bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d145d964b7ff

run "(sha256 0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d4121bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d145d964b7ff)"
0xd2320b2ef89ff3bfa107dfab881c16ef19e4ca3f27197b7d17d685d1064a5aa5

or just in one step

run "(sha256 (concat 0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412 0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 299999999999))"
0xd2320b2ef89ff3bfa107dfab881c16ef19e4ca3f27197b7d17d685d1064a5aa5


The lineage_proof of the solution now takes now parameters instead of 2 since it is not the first spend anymore. The required arguments are:
(parent_parent_coin_info parent_inner_puzzle_hash parent_amount)

In our case it is
(0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412 0xe016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79 299999999999)

The full solution is 
( (0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412 0xe016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79 299999999999) 299999999999  (0xe016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79 299999999997) )

(we give 2 mojos as the farmer fee, singleton has to stay odd)

opc "( (0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412 0xe016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79 299999999999) 299999999999  (0xe016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79 299999999997) )"
ffffa04255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412ffa0e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79ff8545d964b7ff80ff8545d964b7ffffffa0e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79ff8545d964b7fd8080

The returned conditions should be
 ((73 0x45d964b7ff) (71 0xd2320b2ef89ff3bfa107dfab881c16ef19e4ca3f27197b7d17d685d1064a5aa5) (51 0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 0x45d964b7fd)) 
 
 
======> push transaction to the network   cdv rpc pushtx spend_bundle2.json
{
    "status": "SUCCESS",
    "success": true
}

Again, we should find the singleton by executing
cdv rpc coinrecords --by puzzlehash 1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 -ou -nd

{
    "4bfa7a3fce418044a0537ab5c5d4d4d825fc5a8c909976537952fc59d32b3c22": {
        "coin": {
            "amount": 299999999997,
            "parent_coin_info": "0x467a3823cd452a58eddb72feb208c7a9b745cbf79613dd971bd6b2c295b21752",
            "puzzle_hash": "0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1"
        },
        "coinbase": false,
        "confirmed_block_index": 6632189,
        "spent_block_index": 0,
        "timestamp": 1739505206
    }
}

[Suprisingly, this singleton was spent several (many) times, check this link https://alltheblocks.net/chia/coin/0x4255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412?tab=lineage and follow lineage. It looks like the singleton reproduces itself. How is that possible? A thing to think about later....]

About 17 hours later:

The singleton still "reproduces" itself. It looks like there were a bot which spends it all over again, every 2-3 blocks. 

The part below was planned by me execute, but since the singleton was spent, I cannot follow this route anymore. However, if you mimicing it on testnet it should work. 

Skip to (***) to learn the steps I actually performed. 



Now we melt the singleton and send its amount to our address.

Again, since the puzzle_hash is the same, the singleton's coin needs little adjustement in the spend bundle, just the amount, parent_coin_info and solution fields need to be updated. The solution needs to emit the CREATE_COIN condition with amount -113. 

cdv inspect -id coins --parent-id 0xd2320b2ef89ff3bfa107dfab881c16ef19e4ca3f27197b7d17d685d1064a5aa5 --puzzle-hash 0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1 --amount 299999999999 
['952599f0d0d7c8d41fbe7e084f2ab2d31f57a541878a82c7124249e501279405']

The amount is 299999999997.

The solution is
The full solution is 
( (0xd2320b2ef89ff3bfa107dfab881c16ef19e4ca3f27197b7d17d685d1064a5aa5 0xe016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79 299999999999) 299999999997  (0x5f436869615f746f5f7468655f6d6f6f6e5f736f6f6e5f544d5e325f5f5f4450 -113) )

(The puzzle_hash next to -113 does not matter, I just made it 32 bytes long as usual hashes)


opc "( (0xd2320b2ef89ff3bfa107dfab881c16ef19e4ca3f27197b7d17d685d1064a5aa5 0xe016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79 299999999999) 299999999997  (0x5f436869615f746f5f7468655f6d6f6f6e5f736f6f6e5f544d5e325f5f5f4450 -113) )"






Now, we need one more CREATE_COIN condition to "intercept" the amount of that singleton. That condition will be emmited via spending an additional coin. This additional chain will be protected by our singleton_inner_puzzle created above (this time used with no connection to any singleton). 


opc "(a (q 4 (c 2 (c 5 (c 11 ()))) ()) (c (q . 51) 1))"
ff02ffff01ff04ffff04ff02ffff04ff05ffff04ff0bff80808080ff8080ffff04ffff0133ff018080

opc -H "(a (q 4 (c 2 (c 5 (c 11 ()))) ()) (c (q . 51) 1))"
e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79

cdv encode --prefix xch e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79
xch1uqtwrr4lyad9ur0m5za86akxj6d8ylheq0090gmns6h7l9z0heusdtw52s

We need to send 1 mojo to that address (hopefully nobody spends it before us). 

First check whether there is an unspent coin at that address.  

cdv rpc coinrecords --by puzzlehash e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79 -ou -nd

{
    "b38f342223b0718d09589c5d331f5b818b26c25215874d6572185c65474fafe6": {
        "coin": {
            "amount": 100,
            "parent_coin_info": "0x1c100f33d1373ebc613a8f815dbdb738fa5b3af621590a21dde579d9bec496b8",
            "puzzle_hash": "0xe016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79"
        },
        "coinbase": false,
        "confirmed_block_index": 1115907,
        "spent_block_index": 0,
        "timestamp": 1636450143
    }
}

I was lucky, there is an unspent coin at that address. So, I will just use it.

If there is no unspent coin there, send 1 mojo there an re-run the command to get the coin information.


{
  "coin_spends": [
    {
      "coin": {
        "amount": 299999999997,
        "parent_coin_info": "0x952599f0d0d7c8d41fbe7e084f2ab2d31f57a541878a82c7124249e501279405",
        "puzzle_hash": "0x1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1"
      },
      "puzzle_reveal": "0xff02ffff01ff02ffff01ff02ffff03ffff18ff2fff3480ffff01ff04ffff04ff20ffff04ff2fff808080ffff04ffff02ff3effff04ff02ffff04ff05ffff04ffff02ff2affff04ff02ffff04ff27ffff04ffff02ffff03ff77ffff01ff02ff36ffff04ff02ffff04ff09ffff04ff57ffff04ffff02ff2effff04ff02ffff04ff05ff80808080ff808080808080ffff011d80ff0180ffff04ffff02ffff03ff77ffff0181b7ffff015780ff0180ff808080808080ffff04ff77ff808080808080ffff02ff3affff04ff02ffff04ff05ffff04ffff02ff0bff5f80ffff01ff8080808080808080ffff01ff088080ff0180ffff04ffff01ffffffff4947ff0233ffff0401ff0102ffffff20ff02ffff03ff05ffff01ff02ff32ffff04ff02ffff04ff0dffff04ffff0bff3cffff0bff34ff2480ffff0bff3cffff0bff3cffff0bff34ff2c80ff0980ffff0bff3cff0bffff0bff34ff8080808080ff8080808080ffff010b80ff0180ffff02ffff03ffff22ffff09ffff0dff0580ff2280ffff09ffff0dff0b80ff2280ffff15ff17ffff0181ff8080ffff01ff0bff05ff0bff1780ffff01ff088080ff0180ff02ffff03ff0bffff01ff02ffff03ffff02ff26ffff04ff02ffff04ff13ff80808080ffff01ff02ffff03ffff20ff1780ffff01ff02ffff03ffff09ff81b3ffff01818f80ffff01ff02ff3affff04ff02ffff04ff05ffff04ff1bffff04ff34ff808080808080ffff01ff04ffff04ff23ffff04ffff02ff36ffff04ff02ffff04ff09ffff04ff53ffff04ffff02ff2effff04ff02ffff04ff05ff80808080ff808080808080ff738080ffff02ff3affff04ff02ffff04ff05ffff04ff1bffff04ff34ff8080808080808080ff0180ffff01ff088080ff0180ffff01ff04ff13ffff02ff3affff04ff02ffff04ff05ffff04ff1bffff04ff17ff8080808080808080ff0180ffff01ff02ffff03ff17ff80ffff01ff088080ff018080ff0180ffffff02ffff03ffff09ff09ff3880ffff01ff02ffff03ffff18ff2dffff010180ffff01ff0101ff8080ff0180ff8080ff0180ff0bff3cffff0bff34ff2880ffff0bff3cffff0bff3cffff0bff34ff2c80ff0580ffff0bff3cffff02ff32ffff04ff02ffff04ff07ffff04ffff0bff34ff3480ff8080808080ffff0bff34ff8080808080ffff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff2effff04ff02ffff04ff09ff80808080ffff02ff2effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ff02ffff03ffff21ff17ffff09ff0bff158080ffff01ff04ff30ffff04ff0bff808080ffff01ff088080ff0180ff018080ffff04ffff01ffa07faa3253bfddd1e0decb0906b2dc6247bbc4cf608f58345d173adb63e8b47c9fffa04255d1e5b2bcb1d0337c3334b24317d6f8453281f3f7615b735c65a80171d412a0eff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9ffff04ffff01ff02ffff01ff04ffff04ff02ffff04ff05ffff04ff0bff80808080ff8080ffff04ffff0133ff018080ff01808080",
      "solution": "0xffffa0d2320b2ef89ff3bfa107dfab881c16ef19e4ca3f27197b7d17d685d1064a5aa5ffa0e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79ff8545d964b7ff80ff8545d964b7fdffffa05f436869615f746f5f7468655f6d6f6f6e5f736f6f6e5f544d5e325f5f5f4450ff818f8080"
    },
	{
      "coin": {
        "amount": 100,
        "parent_coin_info": "0x1c100f33d1373ebc613a8f815dbdb738fa5b3af621590a21dde579d9bec496b8",
        "puzzle_hash": "0xe016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79"
      },
      "puzzle_reveal": "0xff02ffff01ff04ffff04ff02ffff04ff05ffff04ff0bff80808080ff8080ffff04ffff0133ff018080",
      "solution": "0xffa06e9d36eb2b3289737fd6d0f42dc4c0a46b2bf6505d03c5a827834bfe6d4b8014ff8545d964b80080"
    }
 ],
  "aggregated_signature": "c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
}


If you test the first coin with brun you should get only 2 conditions
((73 0x45d964b7fd) (71 0x952599f0d0d7c8d41fbe7e084f2ab2d31f57a541878a82c7124249e501279405))

We have 299999999997 + 100 mojos to spend. Some of that can go to the blockchain fee.


solution to the second coin 
(0x6e9d36eb2b3289737fd6d0f42dc4c0a46b2bf6505d03c5a827834bfe6d4b8014 300000000000 )

opc "(0x6e9d36eb2b3289737fd6d0f42dc4c0a46b2bf6505d03c5a827834bfe6d4b8014 300000000000 )"
ffa06e9d36eb2b3289737fd6d0f42dc4c0a46b2bf6505d03c5a827834bfe6d4b8014ff8545d964b80080


so 97 mojos will be the fee. 


(***)

Since the singleton was being spent all over agian, preparing a spend_bundle manually was out of question (not enough time between blocks). So, I prepared a python script to do it for me. After several attempts to push the spend_bundle to the network it finally worked. 
I used the same 100 mojo coin which I talk about above. Interesting, it was created back in November 2021. 
I had to make the fee higher since otherwise the transaction would not go through (full blocks?).

According to alltheblocks.net the singleton was spent 315288 times !

I paste my python script below. Hopefully, you can learn something from it. There should be no need for you to use it. This code has not been cleaned up. It has many unused parts. 



That is it! There should be 0.3 xch sitting in my wallet.

DrakoPensulo Feb 13-14, 2025
Cummulative time spent on this challenge: about 20 hours.
Donation address: xch18s2jwxhvx7457ste3pvnqaznjy5rvsgh7nys326y8zlstgc0qepqxgaera



====================

# -*- coding: utf-8 -*-
"""
Created on Fri Feb 14 06:29:57 2025

@author: DrakoPensulo
"""

from blspy import AugSchemeMPL, G2Element


import asyncio
import re


from contextlib import asynccontextmanager
from typing import Any, AsyncIterator, Dict, Iterable, List, Optional, Tuple, Union

from chia_rs import AugSchemeMPL, G1Element, G2Element, PrivateKey
#from blspy import G2Element
#from blspy import AugSchemeMPL, G2Element
from chia.util.byte_types import hexstr_to_bytes

import json

import time

from cdv.util.load_clvm import load_clvm

from chia.rpc.full_node_rpc_client import FullNodeRpcClient
from chia.rpc.wallet_rpc_client import WalletRpcClient
from chia.types.blockchain_format.coin import Coin, coin_as_list
from chia.types.blockchain_format.program import Program
from chia.types.blockchain_format.sized_bytes import bytes32
from chia.types.coin_spend import CoinSpend, make_spend
from chia.types.spend_bundle import SpendBundle
from chia.util.bech32m import encode_puzzle_hash, decode_puzzle_hash
from clvm.casts import int_to_bytes
from chia.util.config import load_config
from chia.util.default_root import DEFAULT_ROOT_PATH
from chia.util.hash import std_hash
from chia.util.ints import uint16, uint64
from chia.wallet.transaction_record import TransactionRecord
from chia.types.condition_opcodes import ConditionOpcode

from chia.wallet.cat_wallet.cat_constants import DEFAULT_CATS
from chia.wallet.cat_wallet.cat_utils import CAT_MOD, CAT_MOD_HASH, construct_cat_puzzle, match_cat_puzzle, NULL_SIGNATURE, ANYONE_CAN_SPEND_PUZZLE, unsigned_spend_bundle_for_spendable_cats, SpendableCAT, get_innerpuzzle_from_puzzle
from chia.wallet.cat_wallet.cat_wallet import CATWallet

from chia.wallet.lineage_proof import LineageProof
#from chia.wallet.puzzles.cat_loader import CAT_MOD
#from chia.wallet.puzzles.cat_loader import CAT_MOD_HASH
from typing import Callable, List, Optional


from chia.wallet.util.tx_config import DEFAULT_TX_CONFIG
from chia.wallet.cat_wallet.lineage_store import CATLineageStore
from chia.wallet.lineage_proof import LineageProof

from chia.util.ints import uint32

from clvm_tools.binutils import assemble
from clvm_tools.clvmc import compile_clvm_text

from clvm.serialize import sexp_from_stream, sexp_to_stream
from clvm_tools.binutils import disassemble


from datetime import datetime
import csv



EMPTY_PROGRAM = Program.to([])


def print_json(dict):
    print(json.dumps(dict, sort_keys=True, indent=4))

from pathlib import Path

#os.environ['CHIA_ROOT'] = 'p:\.chiatestnet\mainnet'
# the below is for TESTNET
#DEFAULT_ROOT_PATH = Path('p:\.chiatestnet11\mainnet').resolve()
DEFAULT_ROOT_PATH = Path('p:\\.chia\\mainnet').resolve()

# config/config.yaml
config = load_config(DEFAULT_ROOT_PATH, "config.yaml")
#config = load_config(CHIA_ROOT, "config.yaml")
self_hostname = config["self_hostname"] # localhost
full_node_rpc_port = config["full_node"]["rpc_port"] # 8555
wallet_rpc_port = config["wallet"]["rpc_port"] # 9256


print(DEFAULT_ROOT_PATH)
print(self_hostname, full_node_rpc_port, wallet_rpc_port)

# ==========================
# from tibet_lib
try:
    from chia.types.blockchain_format.serialized_program import SerializedProgram
except:
    from chia.types.blockchain_format.program import SerializedProgram
def program_from_hex(h: str) -> Program:
    return SerializedProgram.from_bytes(bytes.fromhex(h)).to_program()
# =============================



async def get_puzzle_and_solution_async(coin_id: bytes32, height: uint32): 
    try:
        full_node_client = await FullNodeRpcClient.create(
                self_hostname, uint16(full_node_rpc_port), DEFAULT_ROOT_PATH, config
            )
        puzz_and_sol = await full_node_client.get_puzzle_and_solution(coin_id, height)
 #       coin_records_list = await full_node_client.get_coin_records_by_puzzle_hash(bytes32.fromhex(puzzle_hash),include_spent_coins)
        return puzz_and_sol
    finally:
        full_node_client.close()
        await full_node_client.await_closed()


async def get_coin_record_by_coinid_async(coin_id: bytes32): 
    try:
        full_node_client = await FullNodeRpcClient.create(
                self_hostname, uint16(full_node_rpc_port), DEFAULT_ROOT_PATH, config
            )
#        puzz_and_sol = await full_node_client.get_puzzle_and_solution(coin_id, height)
        coin_record = await full_node_client.get_coin_record_by_name(coin_id)
        return coin_record
    finally:
        full_node_client.close()
        await full_node_client.await_closed()



async def get_coin_records_by_puzzle_hash_async(puzzle_hash:str, include_spent_coins: bool = False, start_height: int = None, end_height: int = None): 
    try:
        full_node_client = await FullNodeRpcClient.create(
                self_hostname, uint16(full_node_rpc_port), DEFAULT_ROOT_PATH, config
            )
        coin_records_list = await full_node_client.get_coin_records_by_puzzle_hash(bytes32.fromhex(puzzle_hash),include_spent_coins)
        return coin_records_list
    finally:
        full_node_client.close()
        await full_node_client.await_closed()




# mine implementations
async def get_network_info_async():
    try:
        full_node_client = await FullNodeRpcClient.create(
                self_hostname, uint16(full_node_rpc_port), DEFAULT_ROOT_PATH, config
            )
#        network_info = await full_node_client.get_network_info()
        network_info = await full_node_client.fetch("get_network_info", {})
        return network_info
    finally:
        full_node_client.close()
        await full_node_client.await_closed()

async def get_blockchain_state_async():
    try:
        full_node_client = await FullNodeRpcClient.create(
                self_hostname, uint16(full_node_rpc_port), DEFAULT_ROOT_PATH, config
            )
#        network_info = await full_node_client.get_network_info()
        blockchain_state = await full_node_client.fetch("get_blockchain_state", {})
        return blockchain_state
    finally:
        full_node_client.close()
        await full_node_client.await_closed()

async def get_block_record_by_height_async(height: int):
    try:
        full_node_client = await FullNodeRpcClient.create(
                self_hostname, uint16(full_node_rpc_port), DEFAULT_ROOT_PATH, config
            )
#        network_info = await full_node_client.get_network_info()
        blockchain_record = await full_node_client.fetch("get_block_record_by_height", {"height": height})
        return blockchain_record
    finally:
        full_node_client.close()
        await full_node_client.await_closed()
    
async def get_block_spends_async(header_hash:str):    
    try:
        full_node_client = await FullNodeRpcClient.create(
                self_hostname, uint16(full_node_rpc_port), DEFAULT_ROOT_PATH, config
            )
#        network_info = await full_node_client.get_network_info()
        block_spends = await full_node_client.fetch("get_block_spends", {"header_hash": header_hash})
        return block_spends
    finally:
        full_node_client.close()
        await full_node_client.await_closed()



network_info = asyncio.run(get_network_info_async())
print_json(network_info)

blockchain_state = asyncio.run(get_blockchain_state_async())
print_json(blockchain_state)
print(blockchain_state["blockchain_state"]["peak"]["height"])
current_height = int(blockchain_state["blockchain_state"]["peak"]["height"])


puzzle_hash = "1bf496f13b75aecdd74ddb67122a96559bb5ac2784ed361b5790f5b4e2ae08d1"


"""
all_coins_with_this_ph = asyncio.run(get_coin_records_by_puzzle_hash_async(puzzle_hash))
print(len(all_coins_with_this_ph))
1/0
"""

coin_to_interceptR = asyncio.run(get_coin_records_by_puzzle_hash_async(puzzle_hash))[0]
coin_to_intercept = coin_to_interceptR.coin

print(coin_to_interceptR)
print(coin_to_intercept)

parent_coin_info = coin_to_intercept.parent_coin_info
height = coin_to_interceptR.confirmed_block_index

pcr = asyncio.run(get_coin_record_by_coinid_async(parent_coin_info))
parent_coin_info = pcr.coin.parent_coin_info


print(pcr)

puz_and_sol = asyncio.run(get_puzzle_and_solution_async(parent_coin_info,height))

print(puz_and_sol)
# we use the same puzzle_reveal , so we just copy it 
pr = puz_and_sol.puzzle_reveal.to_program()

sol = puz_and_sol.solution.to_program()
print(sol)
print(type(sol))
#"correct" the solution
newsol = sol.replace(ff = parent_coin_info, rrfr = -113, rrff = 0x5f436869615f746f5f7468655f6d6f6f6e5f736f6f6e5f544d5e325f5f5f4450 )

newsol = sol.replace(ff = parent_coin_info, rrf = [0x5f436869615f746f5f7468655f6d6f6f6e5f736f6f6e5f544d5e325f5f5f4450, -113] )


print(newsol)
"""
print(newsol.first())
print(newsol.first().first())
print(newsol.first().rest())

print(newsol.rest())
print(newsol.rest().first())
print(newsol.rest().rest())


print(newsol.rest().rest().first().rest())
"""


SINGLETON_INNER_PUZZLE = load_clvm("singleton_inner_puzzle.clsp",package_or_requirement=__name__, search_paths=["../include"])

print(SINGLETON_INNER_PUZZLE)
#print(type(SINGLETON_INNER_PUZZLE))

intercepting_coin = Coin(
    amount = 100,
    parent_coin_info = bytes32.fromhex("1c100f33d1373ebc613a8f815dbdb738fa5b3af621590a21dde579d9bec496b8"),
    puzzle_hash = bytes32.fromhex("e016e18ebf275a5e0dfba0ba7d76c6969a727ef903de57a37386afef944fbe79")
    )
    
print(intercepting_coin)

"""
cs : CoinSpend = make_spend(    
    coin = intercepting_coin,
    puzzle_reveal = SINGLETON_INNER_PUZZLE,
    solution = SINGLETON_INNER_PUZZLE
    )

print(cs)
"""

intercepting_coin_solution = Program.to([ 0x6e9d36eb2b3289737fd6d0f42dc4c0a46b2bf6505d03c5a827834bfe6d4b8014  , 299900000000 ])
intercepting_coin_spend = make_spend(
    intercepting_coin,
    SINGLETON_INNER_PUZZLE,
    intercepting_coin_solution)

print(intercepting_coin_spend)

#I also need the parent coin


intercepted_coin_solution = newsol
#intercepted_coin_solution = Program.to([0x5f436869615f746f5f7468655f6d6f6f6e5f736f6f6e5f544d5e325f5f5f4450, -113])

coin_to_intercept_spend = make_spend(
    coin_to_intercept,
    pr,
    intercepted_coin_solution)



# empty signature i.e., c00000.....
signature = G2Element()

coin_spends = [coin_to_intercept_spend, intercepting_coin_spend ]
spend_bundle = SpendBundle(
        # coin spends
        coin_spends,
        # aggregated_signature
        signature,
    )
print_json(spend_bundle.to_json_dict())


print(parent_coin_info)




====================
